\documentclass[12pt]{article}

\title{Nginx Tutorial}
\author{I. Rifa}

\begin{document}

\maketitle

\section{Organization and inclusions}

The command "include mime.types" includes the mime.types file, in other words,
the contents of the file will be inserted in the current file.
For example:
[nginx.conf]
user nxing nginx;
worker_processes 4;
include other_settings.conf;

[other_settings.conf]
error_log logs/error.log;
pid logs/nginx.pid;

[the final file]
user nxing nginx;
worker_processes 4;
error_log logs/error.log;
pid logs/nginx.pid;

\section{Directive blocks}

The directive blocks are delimited by curly braces.
The root directive block is the main block. For the most part, blocks can be
nested inside other blocks:
 http {
    server {
        listen 80;
        server_name example.com;
        access_log /var/log/nginx/example.com.log;
        location ^~ /admin/ {
            index index.php;
       }
    }
 }

 A server block allows you to configure a virtual host, in other words,
 a website that is hosted on your machine. The server block, in this example,
 contains some configurations that applies to all HTTP requests with a host
 header matching the server_name directive.
 Within the server block, you may insert one or more location blocks. These allows
 you to enable settings based on the request URI.

\section{Core module directives}

\subsection{user}
syntax: user user [group];
syntax: user (user);
The user directive sets the user and group that will be used by worker processes.
If the user and group are undefined, the user and group of the Nginx master process are used.


\section{Events module}
The events module comes with directives that allow you to configure network
mechanisms.

\section{HTTP configuration}
The http block contains directives that apply to the HTTP protocol.

\subsection{http}
This block is inserted at the root of the configuration file. It allows you to
configure the HTTP protocol.

\subsection{server}
This block allows you to declare a website. In other words, a specific
website that is hosted on your machine. This block can only be used within
the http block.

\subsection{location}
This block define a group of settings to be applied to a particular location
on a website. This block can be used within a "server" block or nested within
another "location" block.

\subsection{listen}
Context: server
Specifies the IP address or the port to be used by the server. Sites are
generally served on port 80 (the default value) via HTTP, or 443 via HTTPS.

\subsection{server_name}
Context: server
Assigns one or more hostnames to the "server" block. When Nginx receives an HTTP
request, it uses the "Host" header to match the request to a server block. The first
"server" block to match this hostname is selected.

\subsection{root}
Context: http, server, location, if.
Default value: html (root /usr/share/nginx/html)
Defines the document root, containing the files you wish to serve to your clients.

\subsection{alias}
Context: location. Variable: yes.
It is a directive that you place in a location block only. It assigns a different
path for Nginx to server files from. Consider the following example:
 http {
   server {
       server_name localhost;
       root /var/www/website.com/html;
        location /admin/ {
        alias /var/www/locked/;
      }
   }
 }

 When a request for http://localhost/ is received, files are served from
 /var/www/website.com/html. However, when a request for http://localhost/admin/
 is received, files are served from /var/www/locked/.

\subsection{error_page}
Context: http, server, location, if. Variable: yes.
Allows you to affect URIs to HTTP response code. For example:
error_page 404 /notfound.html;
error_page 403 http://website.com/;
error_page 404 @notfound; # jump to a named location block
error_page 404 =200 /index.html; # in case of 404 error, redirect to
index.html with 200 OK status code.

\subsection{index}
Context: http, server, location. Variable: yes.
Defines the default page that Nginx will serve if no filename is specified in
the request.

\subsection{client_max_body_size}
Context: http, server, location.
Default value: 1m
This is the maximum size of a client request body. If the size is exceeded,
Nginx returns a 413 error to the client.

\section{Reverse proxy mechanism}
\subsection{main directives}
\begin{itemize}
	\item proxy_pass: Specifies that the request should be forwarded to
		the backend server by indicating its location. Syntax:
		proxy_pass http://hostname:port. You may also refer to upstream blocks
		proxy_pass http://myblock;


\subsection{if/elif/else}
number = int(input("Number: "))
if number > 0:
    print("Number is positive")
elif number < 0:
    print("Number is negative")
else:
    print("Number is zero")

\section{sequences}
\begin{itemize}
    \item list : mutable values
    \item tuple : immutable values
    \item set : collection of unique values
    \item dictionary : collection of key-value pairs
\end{itemize}

\subsection{list}
names = ["Harry", "Ron", "Hermione"]
print(names)
print(names[0])
\subsection{tuple}
coordinates = (10.0, 20.0)
\subsection{set}
s = set()
s.add(1)
s.add(3)
s.add(5)
print(s)

\subsection{dictionary}
houses = {"Harry": "Gryffindor", "Draco": "Slytherin"}
houses["Hermione"] = "Gryffindor"
print(houses["Harry"])

\section{loops}
\subsection{for}
for i in range(6):
    print(i)

\section{functions}
def square(x):
    return x * x

for i in range(10):
    print(f"The square of {i} is {square(i)}")

\section{classes}
class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y
p = Point(3, 5)
print(p.x)
print(p.y)

\section{decorators}
def announce(f):
    def wrapper():
        print("About to run the function...")
        f()
        print("Done with the function.")
    return wrapper

@announce
def hello():
    print("Hello, world!")

\section{exceptions}
x = int(input("x: "))
y = int(input("y: "))
try:
    result = x / y
except ZeroDivisionError:
    print("Error: Cannot divide by 0.")
    sys.exit(1)

print(f"{x} / {y} = {result}")


\section{Django}
In order to create a new project, you can use:
django-admin startproject projectName

If we want to run the server, we can use:
python manage.py runserver

In order to create a new app, you can use:
python manage.py startapp appName

\section{migration}
A migration is a file on the migrations folder that contains the instructions to update the database schema.
We should manipulate our models.py file and then run the following commands:
python manage.py makemigrations
python manage.py migrate
In order to create a new row in our database, we can use:
python manage.py shell
from appName.models import ModelName
f = ModelName(field1="value1", field2="value2")
f.save()

If we want to print all the rows of a table, we can use:
ModelName.objects.all() fro example:
>>> from appName.models import ModelName
>>> flights = Flight.objects.all()
>>> flights

If we want to filter the rows of a table, we can use:
ModelName.objects.filter(field1="value1") for example:
>>> from appName.models import ModelName
>>> flights = Flight.objects.filter(origin="Paris")
>>> flights

If we want to get a single row of a table, we can use:
>>> flights = Flight.first()
>>> flights

\subsection{Foreign Keys}
Foreign keys are used to relate two tables. For example, if we want to relate a flight with a passenger, we can use:
class Passenger(models.Model):
    first = models.CharField(max_length=64)
    last = models.CharField(max_length=64)
    flights = models.ManyToManyField(Flight, blank=True, related_name="passengers")

class Flight(models.Model):
    origin = models.ForeignKey(Passenger, on_delete=models.CASCADE, related_name="origin")
    destination = models.ForeignKey(Passenger, on_delete=models.CASCADE, related_name="destination")
    duration = models.IntegerField()

The CASCADE option means that if we delete a passenger, we will delete all the flights related to that passenger.

\end{document}
